---
typora-copy-images-to: img
---

# 多线程学习笔记

#### 1. jvm中线程隔离的区域

​        程序计数器 （记录当前线程执行到哪一行代码）

​		本地方法栈

​		虚拟机栈： 栈帧包含（局部变量表 操作数栈  方法出口 锁记录等）

​		每一个方法执行相当于一个栈帧入栈到出栈的过程

#### 2. cpu的线程上下文切换

​		为了保证每个线程都能运行到 cpu会给每个线程分配时间片（如15ms） 

当cpu时间片的时间耗尽 就需要保存当前线程的信息 然后去执行另外一个线程的时间片

这个过程就是cpu的线程上下文切换

执行上下文切换的时机：

​				线程的 cpu 时间片用完 

​				垃圾回收 

​				有更高优先级的线程需要运行 

​				线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 

当 Context Switch（线程上下文切换） 发生时，需要由操作系统保存**当前线程的状态**，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 

当前线程的状态包括：程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 

Context Switch 频繁发生会影响性能

#### 3..线程的基本操作

start():启动一个新线 程，在新的线程 运行 run 方法 中的代码 

join():等待线程运行结束

sleep():让线程休眠n毫秒 休眠时让出cpu时间片

interrupt():打断线程 并且把打断标记设置为true 

​					如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除打					标记 （打断标记=false）；

​					如果打断的正在运行的线程，则会设置 打断标记(打断标记=true) ；

​					park 的线程被打断，也会设置打断标记 

isInterrupted():返回打断标记

interrupted():返回线程是否被打断线程  并会清楚打断标记

currentThread():返回当前线程

#### 4.设计模式：两阶段终止

​	如何优雅的终止线程

```java
package demo.n2.util;

/**
 * @author zhuliyang
 * @date 2020-03-29
 * @time 23:24
 **/
public class TwoPhaseTermination {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination t = new TwoPhaseTermination();
        t.start();
        Thread.sleep(5000);
        t.stop();
    }
    Thread monitor;
    //启动监控线程
    public void start(){
        monitor = new Thread(()->{
            while (true){
                if (Thread.currentThread().isInterrupted()){
                    System.out.println("料理后事");
                    break;
                }
                System.out.println("监控线程");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();//设置打断标记
                }
            }
        });
        monitor.start();
    }
    //结束监控线程
    public void stop(){
        monitor.interrupt();
    }
}
```

#### 5.线程的6种状态

NEW:   线程创建出来但是没有运行

RUNNABLE： 线程正在运行中

BLOCKED	：线程由于锁的关系 进入阻塞状态

WAITING	：线程进入无限期等待

TIMED_WATING ：线程进入有限时间的等待

TERMINATED	：线程结束运行

#### 6.synchronized

为什么要用sync?

​			并发读写共享变量时 由于cpu任务调度器的原因 可能出现时间片耗完 任务没完成 切换线程  从而产生数据不一致的问题。

i=1  Ta : i++ ,  Tb i--;  期望： i=0   

实际可能：

i++ 可以分成四步                                 i--可以分成四步

1 获取i													 1 获取i			

2 获取增量1											2 获取增量-1

3 对i进行增加1									   3 对i进行增加-1

4 写入i													 4 写入i

 Ta 在执行i++的时候 还没有完成第4步  时间片耗尽  ，

然后cpu去执行Tb 对i-- 在有效的时间片中 完成了i--,

 然后cpu又回来执行第四步;最后写入i=1;

此时出现了**并发问题**  

sync提供了锁的性质 当被锁住的代码线程在**时间片耗尽还没有释放锁**的时候 会持有锁  别的线程尝试获取锁 但是失败了!会**被阻塞** cpu不会分配时间片去执行 阻塞线程  而是会继续分配时间片去执行持有锁的代码 当代码执行完毕 会释放锁 阻塞的线程将会竞争锁 由cpu来决定给哪个线程持有锁。

sync本质是用锁保证了临界区中代码的**原子性**（最小单位 不可分割）从而不会被线程的上下文切换而打断

##### 线程8锁练习

情况1：12 或 21 

```java
public class ThreadEight {
    public synchronized void a() {
        System.out.println(1);
    }
    public synchronized void b() {
        System.out.println(2);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        new Thread(()->threadEight.a()).start();
        new Thread(()->threadEight.b()).start();
    }
}
```

情况2：1s后12，或 2 1s后 1

```java
public class ThreadEight {
    public synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public synchronized void b() {
        System.out.println(2);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        new Thread(()->threadEight.a()).start();
        new Thread(()->threadEight.b()).start();
    }
}
```

情况3：3 1s 12 或 23 1s 1 或 32 1s 1

```java
public class ThreadEight {
    public synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public synchronized void b() {
        System.out.println(2);
    }   
    public synchronized void c() {
        System.out.println(3);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        new Thread(() -> threadEight.a()).start();
        new Thread(() -> threadEight.b()).start();
        new Thread(() -> threadEight.c()).start();
    }
}
```

情况4：2 1s 后 1

```java
public class ThreadEight {
    public synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public synchronized void b() {
        System.out.println(2);
    }
    
    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        ThreadEight threadEight2 = new ThreadEight();
        new Thread(() -> threadEight.a()).start();
        new Thread(() -> threadEight2.b()).start();
    }
}
```

情况5：2 1s 后 1

```java
public class ThreadEight {
    public synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public static synchronized void b() {
        System.out.println(2);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        ThreadEight threadEight2 = new ThreadEight();
        new Thread(() -> threadEight.a()).start();
        new Thread(() -> threadEight2.b()).start();
    }
}
```

情况6：1s 后12， 或 2 1s后 1

```java
public class ThreadEight {
    public static synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public static synchronized void b() {
        System.out.println(2);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        new Thread(() -> threadEight.a()).start();
        new Thread(() -> threadEight.b()).start();
    }
}
```

情况7：2 1s 后 1

```java
public class ThreadEight {
    public static synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public synchronized void b() {
        System.out.println(2);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        ThreadEight threadEight2 = new ThreadEight();
        new Thread(() -> threadEight.a()).start();
        new Thread(() -> threadEight2.b()).start();
    }
}
```

情况8：1s 后12， 或 2 1s后 1

```java
public class ThreadEight {
    public static synchronized void a() {
        Thread.sleep(1000);
        System.out.println(1);
    }
    public static synchronized void b() {
        System.out.println(2);
    }

    public static void main(String[] args) {
        ThreadEight threadEight = new ThreadEight();
        ThreadEight threadEight2 = new ThreadEight();
        new Thread(() -> threadEight.a()).start();
        new Thread(() -> threadEight2.b()).start();
    }
}
```

##### 卖票案例

```java
public class TicketWindow {
    int count = 10000;
    public int sell(){
        if (count>0){
            count--;
            return 1;
        }
        return 0;     
    }

    public static void main(String[] args) throws InterruptedException {
        TicketWindow ticketWindow = new TicketWindow();
        AtomicInteger sell = new AtomicInteger();
        for (int i = 0; i <5000 ; i++) {//模拟5000人买票
            new Thread(()->{
                sell.addAndGet(ticketWindow.sell());
            }).start();
        }
        Thread.sleep(2000);
        System.out.println("卖出"+sell);
        System.out.println("剩余"+ticketWindow.count);
    }
}

卖出5000
剩余5001
解决方法:TicketWindow.sell()方法 加sync //public synchroized int sell()
```

转账案例

```java
package demo.n2;

/**
 * @author zhuliyang
 * @date 2020-04-01
 * @time 0:51
 **/
public class Amount {
    int amount = 1000;

    public  void transfer(Amount anOther, int money) {//给对方账户转账
        this.amount -= money;
        anOther.amount += money;
    }

    public static void main(String[] args) throws InterruptedException {
        Amount a = new Amount();
        Amount b = new Amount();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                a.transfer(b, 1);
            }
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                b.transfer(a, 1);
            }
        });
        t1.start(); t2.start();
        t1.join(); t2.join();
        System.out.println(a.amount+b.amount);
    }
}
运行5次结果：1964 2001  2000 1997 1981 
解决方法  由于是两个对象 需要加类锁   
//   public void transfer(Amount anOther, int money) {//给对方账户转账
//        synchronized (Amount.class) {
//            this.amount -= money;
//            anOther.amount += money;
//        }
//    }
```

##### **Monitor**管程

​	java对象头

​			对象由两部分组成  Mark word  ,  Klass Word （指向对象类型的指针）

​     Mark word   64bit   组成

| unused     | hashcode               | thread                         | age      | biased_lock | 最后两位 |
| ---------- | ---------------------- | ------------------------------ | -------- | ----------- | :------: |
| 未使用空间 | 哈希码                 | 线程信息                       | 分代年龄 | 偏向锁标志  | 加锁状态 |
| **epoch**  | **ptr_to_lock_record** | **ptr_to_heavyweight_monitor** |          |             |          |
| 选择器     | 栈中的锁信息           | 管程信息                       |          |             |          |

![1585840519390](img/1585840519390.png)

Monitor ：操作系统中的管程

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 

Mark Word 中就被设置指向 Monitor 对象的指针 

Monitor 结构如下

![1585840109527](img/1585840109527.png)

##### 重量级锁

刚开始 Monitor 中 Owner 为 null 

当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 

个 Owner 

在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 

EntryList BLOCKED 

Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 

图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 

wait-notify 时会分析 

##### 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争 某段时间始终只有一个线程在调用这个锁），那么可以使用轻量级锁来优化。 



当线程执行锁方法时  jvm会在线程的栈帧中创建锁记录  

当第一个锁记录被创建的时候，让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换锁记录的头信息和Object 的 Mark Word，将 Mark Word 的值存 入锁记录

![1585842573841](img/1585842573841.png)

如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下

![1585843278813](img/1585843278813.png)

如果 cas 失败，有两种情况 

如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入**锁膨胀**过程  升级为重量级锁

如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数 

object reference 指向锁对象  lock record 头信息置为null

![1585843812694](img/1585843812694.png)

当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时栈顶锁记录出栈，表示重 

入计数减一

当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 

头 

成功，则解锁成功 

失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 

##### 锁膨胀

当thread1 使用轻量级锁cas替换锁对象的对象头时 发现锁对象的对象头已经被thread0替换 则会进入重量级锁流程  锁对象的对象头指向操作系统monitor管程 管程中的owner指向thread0  thread1进入entryList;



![1585844334240](img/1585844334240.png)

这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 

即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 

然后自己进入 Monitor 的 EntryList BLOCKED 

![1585844450569](img/1585844450569.png)

当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 

流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程 

##### 重量级锁自旋优化

重量级锁 entryList 中的线程竞争的时候  会先自旋一段时间  如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 变成owner 

阻塞会发生线程的上下文切换 相对于短时间自旋消耗较大。

![1585844865805](img/1585844865805.png)

![1585844902932](img/1585844902932.png)

自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 

在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 

高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 

Java 7 之后不能控制是否开启自旋功能 

##### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 

Java 6 中引入了偏向锁来做进一步优化：**只有第一次使用 CAS** 将线程 ID 设置到对象的 Mark Word 头，之后发现 

这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 

一个对象创建时： 

如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 

thread、epoch、age 都为 0 

偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - 

XX:BiasedLockingStartupDelay=0 来禁用延迟 

如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 

age 都为 0，第一次用到 hashcode 时才会赋值 

##### 偏向锁撤销

**hashcode撤销**

如果调用了对象的hashcode方法 偏向锁的会被取消（应为markword只有64位） hashcode要占用31位 而锁记录要占用54位

轻量级锁会在锁记录中记录 hashCode 

重量级锁会在 Monitor 中记录 hashCode

**多线程访问撤销**

如果多个线程进行访问一个对象 会撤销对象的偏向锁 进入锁升级的过程  如果多线程不是同一时间段访问 会升级成**轻量级锁**  反之 会升级成**重量级锁**

**调用对象的wait/notify时撤销**

wait/notify只有重量级锁才有

**偏向锁升级轻量级锁的代码**

```java
public class TestBiased {
    private static void test2() throws InterruptedException {
        Dog d = new Dog();
        Thread t1 = new Thread(() -> {
            synchronized (d) {//dog对象开始的时候 markword头里面记录着偏向锁的记录
            }
            //此时释放锁  markword头里面记录着偏向锁的记录
            synchronized (TestBiased.class) { //唤醒等待的线程
                TestBiased.class.notify();
            }
        }, "t1");
        t1.start();
        Thread t2 = new Thread(() -> {
            synchronized (TestBiased.class) {//t2执行的时候 直接等待
                try {
                    TestBiased.class.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //此时t2线程持有锁 应为有两个线程持有锁 所以偏向锁升级成轻量级锁 markword被变更
            synchronized (d) {
            }
        }, "t2");
        t2.start();
    }
}
class Dog {

}
```

##### 批量重偏向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID 

当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 

加锁线程 

##### 批量撤销

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 

都会变为不可偏向的，新建的对象也是不可偏向的

##### 锁消除

jvm 会有即时分析器jit 会分析代码运行的时候是否需要加锁 

如下代码  对成员变量o进行加锁  但是这一行为没有意义 所以会执行锁消除

```java
public void b() throws Exception {
 Object o = new Object();
 synchronized (o) {
 x++;
 }
```

#### 7.wait/notify/notifyAll

Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 

BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 

BLOCKED 线程会在 Owner 线程释放锁时唤醒 

WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 

EntryList 重新竞争 

**sleep和wait的区别**

sleep持有锁  wait会放弃锁   

sleep(time)和wait(time) 都是TIMED_WAITING 状态

#### 8.保护性暂停模式

防止虚假唤醒  并且带有时间的等待  

```java
@Slf4j
public class ProtectedStop {
     static  Object res;
    public static void main(String[] args) {
        Object lock = new Object();
        int watiTime = 10000;
        new Thread(() -> {
            log.debug("开始线程");
            long before  = System.currentTimeMillis();
            synchronized (lock) {
                while (res == null) {
                    long after =System.currentTimeMillis();
                    long currentWaitTime = after-before;
                    if (currentWaitTime>=watiTime)break;
                    try {
                        lock.wait(watiTime-currentWaitTime);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("开始干活");
            }

        }).start();
        new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                res = new Object();
                lock.notify();
            }
        }).start();
    }
}
```

#### 9.线程间状态转换

**情况** **1** **NEW** **--> RUNNABLE** 

当调用 t.start() 方法时，由 NEW --> RUNNABLE 

**情况** **2** **RUNNABLE <--> WAITING** 

**t** **线程**用 synchronized(obj) 获取了对象锁后 

调用 obj.wait() 方法时，**t** **线程**从 RUNNABLE --> WAITING 

调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 

竞争锁成功，**t** **线程**从 WAITING --> RUNNABLE 

竞争锁失败，**t** **线程**从 WAITING --> BLOCKED 

**情况** **3** **RUNNABLE <--> WAITING** 

**当前线程**调用 t.join() 方法时，**当前线程**从 RUNNABLE --> WAITING 

注意是**当前线程**在**t** **线程对象**的监视器上等待 

**t** **线程**运行结束，或调用了**当前线程**的 interrupt() 时，**当前线程**从 WAITING --> RUNNABLE 

**情况** **4** **RUNNABLE <--> WAITING** 

当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --> WAITING 

调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING -->  

RUNNABLE 

**情况** **5** **RUNNABLE <--> TIMED_WAITING** 

**t** **线程**用 synchronized(obj) 获取了对象锁后 

调用 obj.wait(long n) 方法时，**t** **线程**从 RUNNABLE --> TIMED_WAITING 

**t** **线程**等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 

竞争锁成功，**t** **线程**从 TIMED_WAITING --> RUNNABLE 

竞争锁失败，**t** **线程**从 TIMED_WAITING --> BLOCKED 

**情况** **6** **RUNNABLE <--> TIMED_WAITING** 

**当前线程**调用 t.join(long n) 方法时，**当前线程**从 RUNNABLE --> TIMED_WAITING 

注意是**当前线程**在**t** **线程对象**的监视器上等待 

**当前线程**等待时间超过了 n 毫秒，或**t** **线程**运行结束，或调用了**当前线程**的 interrupt() 时，**当前线程**从 

TIMED_WAITING --> RUNNABLE 

**情况** **7** **RUNNABLE <*--> TIMED_WAITING** 

当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING 

**当前线程**等待时间超过了 n 毫秒，**当前线程**从 TIMED_WAITING --> RUNNABLE 

**情况** **8** **RUNNABLE <--> TIMED_WAITING** 

当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，**当前线** 

**程**从 RUNNABLE --> TIMED_WAITING 

调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 

TIMED_WAITING--> RUNNABLE 

**情况** **9** **RUNNABLE <--> BLOCKED** 

**t** **线程**用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --> BLOCKED 

持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 **t** **线程**竞争 

成功，从 BLOCKED --> RUNNABLE ，其它失败的线程仍然 BLOCKED 

**情况** **10** **RUNNABLE <--> TERMINATED** 

当前线程所有代码运行完毕，进入 TERMINATED 

#### 10.多把锁

##### 死锁练习

```java
public class SiSuo {
    Object o1 = new Object();
    Object o2 = new Object();
    public void test1(){
        synchronized (o1){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2){ //获取o2时o2被占有--->进入阻塞状态
                System.out.println(1123);
            }
        }
    }
    public void test2(){
        synchronized (o2){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){//获取o1时o1被占有---->进入阻塞状态
                System.out.println(1123);
            }
        }
    }

    public static void main(String[] args) {
        SiSuo siSuo = new SiSuo();
        new Thread(()->siSuo.test1()).start();
        new Thread(()->siSuo.test2()).start();
    }
}
```

#### 11.ReentrantLock

特性：可重入锁，

可打断锁：	

​					加锁lock.lockInterruptibly();     其他线程可以调用  t1.interrupt();方法执行打断  

​					注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断

可等待锁超时：

​					可以使用lock.tryLock()   如果获取不到锁 就不再获取锁线程直接变成TERMINATED

​					可以使用lock.tryLock(long timeout, TimeUnit unit)   如果在指定时间内获取不到锁 就不再获取锁线 					程直接变成TERMINATED

​					TryLock解决死锁代码

```java
@Slf4j
public class DeadLock {
    public static void main(String[] args) {
        ReentrantLock lock1 = new ReentrantLock();
        ReentrantLock lock2 = new ReentrantLock();
        new Thread(() -> {
            lock1.lock();
            log.info("loc1加锁");
            try {
                log.info("开始loc2加锁");
                if (!lock2.tryLock(3, TimeUnit.SECONDS)) {
                    log.info("loc2加锁失败");
                    return;
                }
                lock2.unlock();
                log.info("loc2解锁");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock1.lock();
            log.info("loc1解锁");
        }).start();
        new Thread(() -> {
            lock2.lock();
            log.info("loc2加锁");
            try {
                log.info("开始loc1加锁");
                if (!lock1.tryLock(3, TimeUnit.SECONDS)) {
                    log.info("loc1加锁失败");
                    return;
                }
                lock1.unlock();
                log.info("loc1解锁");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock2.lock();
            log.info("loc2解锁");
        }).start();
    }
}
```

可设置公平性 

```java
ReentrantLock lock = new ReentrantLock(true);
//设置了公平性之后  阻塞队列中获取锁的先后顺序 会按照他的进入阻塞队列的顺序来获得
//但是 如果设置了公平锁 并发度会降低
```

可设置waitSet,

synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 

ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 

synchronized 是那些不满足条件的线程都在一间休息室等消息 

而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 

醒 

使用要点： 

await 前需要获得锁 

await 执行后，会释放锁，进入 conditionObject 等待 

await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 

竞争 lock 锁成功后，从 await 后继续执行

代码示例

```java
@Slf4j
public class TestCondition {
    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        Condition condition1 = lock.newCondition();
        Condition condition2 = lock.newCondition();
        new Thread(() ->{
            lock.lock();
            try {
                log.debug("开始等烟");
                condition1.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("开始抽烟");
            lock.unlock();
        }).start();
        new Thread(() ->{
            lock.lock();
            try {
                log.debug("开始等外卖");
                condition2.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("开始吃外卖");
            lock.unlock();
        }).start();
        Sleeper.sleep(3);
        lock.lock();
        log.debug("烟来了");
        condition1.signal();
        log.debug("外卖来了");
        condition2.signal();
        lock.unlock();
    }
}
```

#### 12 多线程顺序控制

wait/notify 版本

```java
public class PrintABCWaitNotify {
    int flag = 1;

    public void print(int curflag, int nextFalg, String str) {
        synchronized (this) {
            for (int i = 0; i < 5; i++) {
                while (flag != curflag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                this.notifyAll();
                flag = nextFalg;
            }
        }
    }

    public static void main(String[] args) {
        PrintABCWaitNotify p = new PrintABCWaitNotify();
        new Thread(() -> { p.print(1, 2, "A"); }).start();
        new Thread(() -> { p.print(2, 3, "B"); }).start();
        new Thread(() -> { p.print(3, 1, "C"); }).start();
    }
}
```

ReentrantLock版本1

```java
public class PrintABCReentrantLock {
    int flag = 1;
    ReentrantLock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    public void print(int cur, int next, String str) {
        for (int i = 0; i < 5; i++) {
            try {
                lock.lock();
                while (flag!=cur){
                    condition.await();
                }
                System.out.print(str);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                condition.signalAll();
                flag = next;
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        PrintABCReentrantLock p = new PrintABCReentrantLock();
        new Thread(() ->{p.print(1,2 , "A");}).start();
        new Thread(() ->{p.print(2,3 , "B");}).start();
        new Thread(() ->{p.print(3,1 , "C");}).start();
    }
}
```

ReentrantLock版本2

```java
public class PrintABCReentrantLock2 {
    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        Condition condition1 = lock.newCondition();
        Condition condition2 = lock.newCondition();
        Condition condition3 = lock.newCondition();
        new Thread(() -> {
            lock.lock();
            for (int i = 0; i < 5; i++) {
                try {
                    condition1.await();
                    System.out.print("A");
                    condition2.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            lock.unlock();
        }).start();
        new Thread(() -> {
            lock.lock();
            for (int i = 0; i < 5; i++) {
                try {
                    condition2.await();
                    System.out.print("B");
                    condition3.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            lock.unlock();
        }).start();
        new Thread(() -> {
            lock.lock();
            for (int i = 0; i < 5; i++) {
                try {
                    condition3.await();
                    System.out.print("C");
                    condition1.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            lock.unlock();
        }).start();
        Sleeper.sleep(1);
        lock.lock();
        condition1.signal();
        lock.unlock();
    }
}
```

park/unpark 版本

```java
public class PrintABCParkUnPark {
    static Thread t1;
    static Thread t2;
    static Thread t3;
    public static void main(String[] args) {
         t1= new Thread(() ->{
            for (int i = 0; i <5 ; i++) {
                LockSupport.park();
                System.out.print("A");
                LockSupport.unpark(t2);
            }
        });
        t2= new Thread(() ->{
            for (int i = 0; i <5 ; i++) {
                LockSupport.park();
                System.out.print("B");
                LockSupport.unpark(t3);
            }
        });
        t3= new Thread(() ->{
            for (int i = 0; i <5 ; i++) {
                LockSupport.park();
                System.out.print("C");
                LockSupport.unpark(t1);
            }
        });
        t1.start();
        t2.start();
        t3.start();
        LockSupport.unpark(t1);
    }
}
```

总结：synchionzed 是jvm层面 c++实现

​			rerntrantLock 是java层面 java实现

​			LockSupport 是操作系统层面 c实现

#### 13.jmm

内存可见性

下面代码会发生结束不了的问题

```java
public class Test {
    static  boolean  run = true;
    public static void main(String[] args) {
        new Thread(() ->{
            while (run){

            }
            System.out.println("jeishule1");
        }).start();
        Sleeper.sleep(5);
        run=false;
    }
}
```

1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。

   ![1586272759593](img/1586272759593.png)

   2. 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 

   减少对主存中 run 的访问，提高效率

   

![1586272782797](img/1586272782797.png)

3. 5 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 

的值，结果永远是旧值

![1586272816367](img/1586272816367.png)

​	解决办法

```java
static  volatile   boolean  run = true;
```

synchionized: 可见性，原子性

volatile : 可见性

**指令重排**

事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令 

还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据 

写回 这 5 个阶段 

![1586276717296](img/1586276717296.png)

在不改变程序结果的前提下，这些指令的各个阶段可以通过**重排序**和**组合**来实现**指令级并行**，这一技术在 80's 中 

叶到 90's 中叶占据了计算架构的重要地位。 

**提示：** 

分阶段，分工是提升效率的关键！ 

指令重排的前提是，重排指令不能影响结果，例如

**** **支持流水线的处理器** 

现代 CPU 支持**多级指令流水线**，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理 

器，就可以称之为**五级指令流水线**。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 

条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了 **指令地吞吐率**。 

![1586276801965](img/1586276801965.png)

由于cpu支持多级流水线处理  在不改变运算结果的情况下，为了提高指令吞吐率， cpu会进行指令重排序！ 

如下代码

```java
@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {

    int num = 0;
    boolean ready = false;
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }

}
```

4000万次并发测试之后

线程1返回的结果中r.r1 会有三种情况  

```java
           0         1,515   ACCEPTABLE_INTERESTING  !!!!
           1    11,815,113               ACCEPTABLE  ok
           4    26,080,973               ACCEPTABLE  ok
```
1 对应actor1先执行

4 对应actor2先执行

0 对应actor2被指令重排   actor2执行到第1行结束 第二行未开始   actor1方法执行   r.r1 =  0 + 0;

```java
@Actor
public void actor2(I_Result r) {
    ready = true; //1
    num = 2; //2
}
```

解决办法 ：防止指令重排

```java
public class ConcurrencyTest {

    int num = 0;
    volatile boolean ready = false; //添加volatile关键字 可以防止本行和之前的行指令重排序
	//.....
}
```

volatile 保证了有序性。

#### 14. volatile

volatile  本质是给指令加了一层内存屏障  

**可见性**

对volatile变量的写指令之后 会加入写屏障： 写屏障保证在写屏障之前的共享变量的变动，全部都写到主存中

对volatile变量的读指令之前 会加入读屏障：读屏障保证在读屏障之后的读取， 全部去主存中去读

```java
public void actor2(I_Result r) { 

 int num = 2; 
 volatile boolean ready = true; // ready 是 volatile 赋值带内存屏障 

 public void write(){
     new Thread(()->{
         num =1;
         ready =false;
         //写屏障  会把写屏障之前的写变化 全部写道主存中
     }).start();
 }
    
 public void read(){
     new Thread(()->{
         //读屏障  读屏障保证在读屏障之后的读取， 全部去主存中去读
		 boolean res = ready;
         int i = num;
     }).start();
 }

}
```

**有序性**

写屏障保证了 指令重排时 写屏障之后的代码 不会被重排到写屏障之前

读屏障保证了 指令重排时 读屏障之前的代码 不会被重排到读屏障之后 

更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性

#### 15.happens-before

线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见

```java
static int x; 
static Object m = new Object(); 

new Thread(()->{ 
 synchronized(m) { 
 	x = 10;
  }
},"t1").start();
new Thread(()->{
 synchronized(m) {
 	System.out.println(x);
  }
},"t2").start()
```

线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

```java
volatile static int x;
new Thread(()->{
 x = 10;
},"t1").start();
new Thread(()->{
 System.out.println(x);
},"t2").start();
```

线程 start 前对变量的写，对该线程开始后对该变量的读可见

```java
static int x; x = 10;
new Thread(()->{
 System.out.println(x);
},"t2").start();
```

线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 

它结束） 

```java
static int x;
Thread t1 = new Thread(()->{
 x = 10;
},"t1");
t1.start();
t1.join();
System.out.println(x);
```

线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 

t2.interrupted 或 t2.isInterrupted） 

```java
static int x;
public static void main(String[] args) {
 Thread t2 = new Thread(()->{
 while(true) {
 if(Thread.currentThread().isInterrupted()) {
 System.out.println(x);
 break;
 }
 }
 },"t2");
 t2.start();
 new Thread(()->{
 sleep(1);
 x = 10;
 t2.interrupt();
 },"t1").start();
 while(!t2.isInterrupted()) {
 Thread.yield();
 }
 System.out.println(x);
}
```

对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 

具有传递性，如果 x hb-> y 并且 y hb-> z 那么有 x hb-> z ，配合 volatile 的防指令重排，有下面的例子

```java
volatile static int x;
static int y;
new Thread(()->{ 
 y = 10;
 x = 20;
},"t1").start();
new Thread(()->{
 // x=20 对 t2 可见, 同时 y=10 也对 t2 可见
 System.out.println(x); 
},"t2").start();
```

#### 16 CAS

cas是一种无锁的并发  体现的思想是比较并交换 cas需要配合volatile 一起使用才可以保证无锁并发

```java
public class CastTest {
    public static void main(String[] args) {
        Inner inner = new Inner();
        for (int i = 0; i <100 ; i++) {
            new Thread(()->{inner.add(10);}).start();
        }
        Sleeper.sleep(1);
        System.out.println(inner.get());
    }

    static class Inner {
        AtomicInteger i = new AtomicInteger();
        int get() {
            return i.get();
        }
        void add(int inc) {
            while (true) {
                int except = this.i.get();
                int update = except + inc;
                //比较并交换 如果期望值=主存中的值 就进行交换 并返回true 跳出循环 否则 返回false 进入下次循环
                if (i.compareAndSet(except, update)) {
                    return;
                }
            }
        }
    }
}
```

cas并不会无线的自旋  jvm会控制自旋的次数 如果多次自旋失败  那么就会停止自旋 cas失败

```java
//极限并发下 jvm会控制自旋的次数  cas会失败
public class MyAtomicInteger {
    Unsafe unsafe;
    int value;
    long valueOffset;
    public MyAtomicInteger(int initValue) throws NoSuchFieldException, IllegalAccessException {
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        //反射获取对象
        this.unsafe = (Unsafe) theUnsafe.get(null);
        Field fieldValue = MyAtomicInteger.class.getDeclaredField("value");
        //获取域的偏移地址
        this.valueOffset = unsafe.objectFieldOffset(fieldValue);
        this.value = initValue;
    }
    public void add(int add){
            int prev = value;
            int post = value+add;
            if(!unsafe.compareAndSwapInt(this, valueOffset,prev , post)){
                System.out.println(false);
            }
    }

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        MyAtomicInteger myAtomicInteger = new MyAtomicInteger(0);
        for (int i = 0; i <100000 ; i++) {
            new Thread(()->{myAtomicInteger.add(1);}).start();
        }
        Sleeper.sleep(3);//等3秒
        System.out.println(myAtomicInteger.value);
    }
}

//打印
//false
//false
//false
//false
//false
//false
//false
//false
//false
//false
//false
//false
//false
//false
//false
//99985
```

CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 

重试呗。 

synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 

改，我改完了解开锁，你们才有机会。 

CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 

因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 

但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响

#### 17.AtomicInteger

```java
public class CastTest {
    public static void main(String[] args) {
        Inner inner = new Inner();
        for (int i = 0; i <10; i++) {
            new Thread(()->{inner.calculate(prev -> ((prev*2)+3)/2 );}).start();
        }
        Sleeper.sleep(1);
        System.out.println(inner.get());
    }

    static class Inner {
        AtomicInteger i = new AtomicInteger(1);
        int get() {
            return i.get();
        }
        void add(int inc) {
            while (true) {
                int except = this.i.get();
                int update = except + inc;
                if (i.compareAndSet(except, update)) {
                    return;
                }
            }
        }
        void calculate(Eval eval) {
            while (true) {
                int except = this.i.get();
                int update = eval.calculate(except);//通过接口计算后的值
                if (i.compareAndSet(except, update)) {
                    return;
                }
            }
        }
    }
}
```

```java
@FunctionalInterface
public interface Eval {
    //接口的计算过程由实现类来实现
    int calculate(int prev);
}
```

18 cas ABA问题

对于cas操作  如果本线程想改变值A->B, 如果此时其他线程对对象值做了修改 例如 从A->B  B->A  对于本线程是无法感知到的  ,依旧会cas操作成功。

如何解决cas ABA问题？

添加版本号   用自带版本号的原子类 AtomicStampedReference 这个类内部有一个版本号  被线程修改一次 版本号+1；

#### 18.原子累加器

自jdk8 之后 有一类新的原子类 专门用来做累加  如 LongAdder  性能比AtomicInteger 快 5倍左右

为什么这么快？？

传统的cas操作 当竞争激烈是 cas操作就会失败概率变高  自旋的次数也就增加 耗时也就增加

LongAdder 内部维护了多个累加单元 （与cpu的核心数有关）当竞争激烈时 它可以对多个累加单元同时做cas操作

最后再把累加单元的值汇总即可。 

#### 19.LongAdder

LongAdder 继承自父类Striped64

有如下 关键属性

```java
//累加的数组  不同线程按照hash值 在不同的数组元素中累加 
transient volatile Cell[] cells;
//没有线程竞争时的 单个累加值
transient volatile long base;
//在cells 扩容或者创建时 置为1 表示正在扩容
transient volatile int cellsBusy;
```

Striped64内部维护了一个线程安全的数组 cell[];

会根据线程的hash值 计算对应的分段 。 计算方式： hash&(length-1)

然后各自维护每个元素的计数，当计数结束后，汇总整个数组，即可得到结果。

相比于cas的atomicInteger  LongAdder的并发力度更加高。

Striped64内部类Cell

```java
@sun.misc.Contended //这个注解是为了防止cpu缓存的伪共享
static final class Cell {
    volatile long value;
    Cell(long x) { value = x; }
    final boolean cas(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }
	//省略
}
```

cpu缓存

![1586617259527](img/1586617259527.png)



为什么设置三级缓存？  

速度比较

![1586617298175](img/1586617298175.png)

因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 

**而缓存以缓存行为单位**，每个缓存行对应着一块内存，一般是 64 byte（8 个 long） 

缓存的加入会造成数据副本的产生，即**同一份数据会缓存在不同核心的缓存行中** 

CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效

![1586617655203](img/1586617655203.png)

因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 

此缓存行可以存下 2 个的 Cell 对象。这样问题来了： 

Core-0 要修改 Cell[0] 

Core-1 要修改 Cell[1] 

无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 

Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效 

@sun.misc.Contended 用来解决这个问题，它的原理是在**使用此注解的对象或字段的前后各增加 128 字节大小的** 

**padding**，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效 

![1586617790910](img/1586617790910.png)

longAdder add方法：

```java
public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    //数组不为空  或者  设置base不成功
    if ((as = cells) != null || !casBase(b = base, b + x)) {
        boolean uncontended = true;
        //数组为空 或者 数组长度小于0 或者 计算出来的数组下标为空 或者 cas累加不成功 进入longAccumulate（）方法  否则 累加成功！
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[getProbe() & m]) == null ||
            !(uncontended = a.cas(v = a.value, v + x)))
            longAccumulate(x, null, uncontended);
    }
}
```

```java
final void longAccumulate(long x, LongBinaryOperator fn,
                          boolean wasUncontended) {
    int h;
    if ((h = getProbe()) == 0) {
        ThreadLocalRandom.current(); // force initialization
        h = getProbe();
        wasUncontended = true;
    }
    boolean collide = false;                // True if last slot nonempty
    for (;;) { //cas循环赋值
        Cell[] as; Cell a; int n; long v;
        //如果数组不为空 就进行赋值
        if ((as = cells) != null && (n = as.length) > 0) {
            //数组元素为空 初始化
            if ((a = as[(n - 1) & h]) == null) {
                if (cellsBusy == 0) {       // Try to attach new Cell
                    Cell r = new Cell(x);   // Optimistically create
                    if (cellsBusy == 0 && casCellsBusy()) {
                        boolean created = false;
                        try {               // Recheck under lock
                            Cell[] rs; int m, j;
                            if ((rs = cells) != null &&
                                (m = rs.length) > 0 &&
                                rs[j = (m - 1) & h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            //元素不为空 进行累加
            else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                         fn.applyAsLong(v, x))))
                break;
            else if (n >= NCPU || cells != as)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            //扩容cells
            else if (cellsBusy == 0 && casCellsBusy()) {
                try {
                    if (cells == as) {      // Expand table unless stale
                        Cell[] rs = new Cell[n << 1]; //扩容两倍  后半部分时全新的
                        for (int i = 0; i < n; ++i)
                            rs[i] = as[i];
                        cells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = advanceProbe(h); //如果前面的if elseIf 全部不满足 改变线程的cell对象 继续去累加
        }
        //如果数组为空 并且 别的线程没有创建或者扩容 cell数组  并且 CellsBusy加锁成功
        //进行数组初始化
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
            boolean init = false;
            try {                           // Initialize table
                if (cells == as) {
                    Cell[] rs = new Cell[2];
                    rs[h & 1] = new Cell(x);
                    cells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        //其他情况  返回使用base记录累加值
        else if (casBase(v = base, ((fn == null) ? v + x :
                                    fn.applyAsLong(v, x))))
            break;                          // Fall back on using base
    }
}
```

#### 20.Unsafe

非常底层的一个类 可以直接操作内存 进行操作系统的cas操作等 叫Unsafe 就是让你别用 你不会的 看看就行了

unsafe 直接操作内存案例

```java
public class UnsafeTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
//        LongAdder longAdder = new LongAdder();
        //反射获取unsafe 的thUnsafe属性
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        Unsafe unsafe = (Unsafe) theUnsafe.get(null);
        Man man = new Man();
        Field name = Man.class.getDeclaredField("name");
        Field age = Man.class.getDeclaredField("age");
        //获取域的偏移地址
        long offset1 = unsafe.objectFieldOffset(name);
        long offset2 = unsafe.objectFieldOffset(age);
        //cas设置 数据
        unsafe.compareAndSwapObject(man, offset1, null, "张三");
        unsafe.compareAndSwapInt(man, offset2, 0,22);
        System.out.println(man.name+":"+man.age);
    }
}

class Man {
    String name;
    int age;
}
```

unsafe 模拟 atomicInteger

```java
public class MyAtomicInteger {
    Unsafe unsafe;
    int value;
    long valueOffset;//成员变量value的偏移地址
    //构造方法
    public MyAtomicInteger(int initValue) throws NoSuchFieldException, IllegalAccessException {
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        //反射获取对象
        this.unsafe = (Unsafe) theUnsafe.get(null);
        Field fieldValue = MyAtomicInteger.class.getDeclaredField("value");
        //获取域的偏移地址
        this.valueOffset = unsafe.objectFieldOffset(fieldValue);
        this.value = initValue;
    }
    public void add(int add){
        while (true){
            int prev = value;
            int post = value+add;
            if (unsafe.compareAndSwapInt(this, valueOffset,prev , post)){
                break;
            }
        }
    }

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        MyAtomicInteger myAtomicInteger = new MyAtomicInteger(0);
        for (int i = 0; i <1000 ; i++) {
            new Thread(()->{myAtomicInteger.add(1);}).start();
        }
        Sleeper.sleep(1);//等一秒 
        System.out.println(myAtomicInteger.value);
    }
}
```

#### 21.享元模式

目的：内存使用最大化

行为：当我们对重复获取相同值的对象时 返回的对象对象是同一个

在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 

valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 

象 

```java
public static Long valueOf(long l) { 
 	final int offset = 128; 
 	if (l >= -128 && l <= 127) { // will cache 
 		return LongCache.cache[(int)l + offset]; 
	} 
	return new Long(l); 
}
```

#### 22.线程池

##### 1自定义线程池

```java
package demo.threadPool;

import demo.util.Sleeper;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author zhuliyang
 * @date 2020-04-13
 * @time 0:07
 **/
@Slf4j
public class MyThreadPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(new BlockingQueue<>(10),
                2,
                1, TimeUnit.SECONDS,
                //拒绝策略
                //1 死等
//                (task,deque)->{deque.put(task);});
                //2.有时间的等待
//                (task,deque)->{deque.putByTimeOut(task,1, TimeUnit.SECONDS);});
                //3抛异常
//                (task,deque)->{throw new RuntimeException("任务执行失败");});
                //4 让调用者放弃多余的任务 不进入队列
//                (task,deque)->{ log.debug("不进入队列"); });
                //5 让调用者执行多余的任务
                (task,deque)->{ task.run(); });
        for (int i = 0; i <15 ; i++) {
            int j =i;
            threadPool.excute(() ->{
                Sleeper.sleep(3);
                System.out.println(j);
            });
        }
    }
}
@FunctionalInterface
interface Reject<T>{
    void doReject(T task,BlockingQueue<T> deque);
}

@Slf4j
class ThreadPool{
    //任务队列
    private BlockingQueue<Runnable> taskQueue;
    //线程集合
    private final HashSet<Worker> workers = new HashSet<>();
    //核心线程数
    private int coreSize;
    //获取任务的超时时间
    private long timeout;

    private TimeUnit timeUnit;

    private Reject<Runnable> reject;

    public void excute(Runnable task){
        synchronized (workers){
            if (workers.size()<coreSize){ //如果线程数 小于核心线程数
                Worker worker = new Worker(task);
                workers.add(worker);
                worker.start(); //异步启动线程
            }else {
                //执行拒绝策略
                taskQueue.putWithReject(reject,task);
            }
        }
    }

    //内部类 ：任务
    class Worker extends Thread{
        Runnable task ;
        public Worker(Runnable task){
            this.task = task;
        }
        @Override
        public void run() {
            workers.add(this);
            while (task!=null){
                try {
                    log.debug("正在执行{}",task);
                    task.run();
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    //有限时间的阻塞获取  超时了就返回null 将会跳出while循环
                    task = taskQueue.takeByTimeOut(timeout, timeUnit);
                }
            }
            //如果线程获取任务超时  删除对应的线程
            synchronized (workers){
                log.debug("移除任务{}",this);
                workers.remove(this);
            }
        }
    }

    public ThreadPool(BlockingQueue<Runnable> taskQueue, int coreSize, long timeout, TimeUnit timeUnit,Reject<Runnable> reject) {
        this.taskQueue = taskQueue;
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.reject = reject;
    }


}
@Slf4j
class BlockingQueue<T>{
    //任务队列
    private Deque<T> deque = new ArrayDeque<>();
    //锁
    private ReentrantLock lock = new ReentrantLock();
    //生产者条件变量
    private Condition fullWaitSet = lock.newCondition();
    //消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();
    //容量
    private int capcity;

    public BlockingQueue(int capcity) {
        this.capcity = capcity;
    }

    //阻塞获取队列头元素的方法
    public T take(){
        try {
            lock.lock();
            //如果队列为空 就阻塞
            while (!deque.isEmpty()){
                emptyWaitSet.await();//消费者线程等待
            }
            T poll = deque.poll();
            fullWaitSet.signal();//叫醒阻塞的生产者线程
            return poll ;//返回队列头部的元素
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return null;
    }

    //阻塞获取队列头元素的方法
    public T takeByTimeOut(long timeOut, TimeUnit timeUnit){
        try {
            long nanos = timeUnit.toNanos(timeOut);//将超时时间转换成纳秒
            lock.lock();
            //如果队列为空 就阻塞
            while (deque.isEmpty()){
                if (nanos<=0){
                    log.debug(" 等待超时 ");
                    return null;
                }
                //awaitNanos() 返回  剩余的时间 =参数nanos - 被虚假唤醒时经过的时间
                nanos = emptyWaitSet.awaitNanos(nanos);//消费者线程等待纳秒级别
            }
            T poll = deque.poll();
            log.debug("获取队列任务",poll);
            fullWaitSet.signal();//叫醒阻塞的生产者线程
            return poll ;//返回队列头部的元素
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return null;
    }
    //阻塞给队列尾部添加元素
    public void put(T task){
        try {
            lock.lock();
            //如果队列满了 生产者线程等待
            while (deque.size()>=capcity){
                fullWaitSet.await();
            }
            log.debug("核心线程已满 往队列添加任务{}",task);
            deque.add(task);//往队列尾部添加元素
            emptyWaitSet.signal();//叫醒阻塞的消费者
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    //阻塞给队列尾部添加元素(带超时的)
    public boolean putByTimeOut(T task,long timeOut, TimeUnit timeUnit){
        try {
            long nanos = timeUnit.toNanos(timeOut);//将超时时间转换成纳秒
            lock.lock();
            //如果队列满了 生产者线程等待(有限时间的)
            while (deque.size()>=capcity){
                if (nanos<=0){
                    log.debug("添加超时");
                    return false;
                }
                nanos = fullWaitSet.awaitNanos(nanos);
            }
            log.debug("核心线程已满 往队列添加任务{}",task);
            deque.add(task);//往队列尾部添加元素
            emptyWaitSet.signal();//叫醒阻塞的消费者
            return true;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return true;
    }
    //获取队列大小
    public int size(){
        return deque.size();
    }

    //执行拒绝策略的 加入任务队列
    public void putWithReject(Reject<T> reject, T task) {
        try {
            lock.lock();
            if (deque.size()<=capcity){
                deque.add(task);
            }else {
                reject.doReject( task, this);
                emptyWaitSet.signalAll();
            }
        }finally {
            lock.unlock();
        }
    }
}
```

##### 2 拒绝策略

如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它 

著名框架也提供了实现 

AbortPolicy ：让调用者抛出 RejectedExecutionException 异常，这是默认策略

CallerRunsPolicy ：让调用者运行任务 

DiscardPolicy： 放弃本次任务 

DiscardOldestPolicy ：放弃队列中最早的任务，本任务取而代之 

Dubbo: 在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题 

Netty : 是创建一个新线程来执行任务 

ActiveMQ: 带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 

PinPoint:   它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略

##### 3 线程池批量处理带返回的任务

```java
@Slf4j
public class TestExecutors {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        //执行一个任务列表  并且返回任务返回值列表
        List<Future<String>> futures = threadPool.invokeAll(Arrays.asList(
                () -> {
                    Sleeper.sleep(3);
                    log.debug("task1");
                    return "1";
                },
                () -> {
                    Sleeper.sleep(3);
                    log.debug("task2");
                    return "2";
                },
                () -> {
                    Sleeper.sleep(3);
                    log.debug("task3");
                    return "3";
                }
        ));
        futures.forEach(f -> {
            try {
                log.debug(f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
}
```

##### 4 关闭线程池

**shutdown**

```java
/*
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但已提交任务会执行完
- 此方法不会阻塞调用线程的执行
*/
void shutdown();
```

```java
public void shutdown() {
 	final ReentrantLock mainLock = this.mainLock;
 	mainLock.lock();
	try {
        //验证权限
		 checkShutdownAccess();
	 	// 修改线程池状态
 		advanceRunState(SHUTDOWN);
	 	// 仅会打断空闲线程
 		interruptIdleWorkers();
 		onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
 	} finally {
 		mainLock.unlock();
 	}
 	// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)
 	tryTerminate();
}
```

**shutdownNow**

```java
/*
线程池状态变为 STOP
- 不会接收新任务
- 会将队列中的任务返回
- 并用 interrupt 的方式中断正在执行的任务
*/
List<Runnable> shutdownNow();
```

```java
public List<Runnable> shutdownNow() {
 	List<Runnable> tasks;
 	final ReentrantLock mainLock = this.mainLock;
 	mainLock.lock();
 	try {
 		checkShutdownAccess();
 		// 修改线程池状态
		 advanceRunState(STOP);
 		// 打断所有线程
 		interruptWorkers();
 		// 获取队列中剩余任务
 		tasks = drainQueue();
 	} finally {
 		mainLock.unlock();
 	}
 	// 尝试终结
	tryTerminate();
 	return tasks;
}
```

##### 5 创建多少线程合适

计算密集型： 线程数=cpu核数+1    +1是为了防止有的线程故障 可以顶上去

io密集型： 如 4核cpu计算时间是50%  io等待时间是50%    

##### 6 常用的线程池的种类

​	FixedThreadPool  :队列长度无线长 

​	SingleThreadPool：单个线程 队列长度无线长 

​	CachedThreadPool：可以开无限多线程

​	scheduledThreadPool：可以开无限多线程

#### 23 aqs

aqs 内部结构

##### **一个 volatile int state**  

表示资源的状态（分独占模式和共享模式）子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 

​		getState - 获取 state 状态 

​		setState - 设置 state 状态 

​		compareAndSetState - cas 机制设置 state 状态 

​		独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源

##### **一个owner**

​		表示当前锁的持有线程

##### **阻塞队列：一个双向Node链表** 

​		类似于 Monitor 的 EntryList

##### 等待队列：一个双向Node链表

  	  类似于 Monitor 的 WaitSet

#####  链表节点 Node  

```java
static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node();
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1;
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1;
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2;
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3;

    /**
		是否等待
     */
    volatile int waitStatus;

    /**
		前一个节点
     */
    volatile Node prev;

    /**
		下一个节点
     */
    volatile Node next;

    /**
		节点的线程属性
     */
    volatile Thread thread;

    /**
		下一个等待节点
     */
    Node nextWaiter;

    /**
     * Returns true if node is waiting in shared mode.
     */
    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    /**
     * Returns previous node, or throws NullPointerException if null.
     */
    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    Node() {    // Used to establish initial head or SHARED marker
    }

    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
```

##### **ConditionObject **  

条件变量来实现等待、唤醒机制，支持多个条件变量，

```java
public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;
    /** First node of condition queue. */
    private transient Node firstWaiter;
    /** Last node of condition queue. */
    private transient Node lastWaiter;

    /**
     * Creates a new {@code ConditionObject} instance.
     */
    public ConditionObject() { }

    // Internal methods

    /**
     * Adds a new waiter to wait queue.
     * @return its new wait node
     */
    private Node addConditionWaiter() {
        Node t = lastWaiter;
        // If lastWaiter is cancelled, clean out.
        if (t != null && t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        if (t == null)
            firstWaiter = node;
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }

    /**
     * Removes and transfers nodes until hit non-cancelled one or
     * null. Split out from signal in part to encourage compilers
     * to inline the case of no waiters.
     * @param first (non-null) the first node on condition queue
     */
    private void doSignal(Node first) {
        do {
            if ( (firstWaiter = first.nextWaiter) == null)
                lastWaiter = null;
            first.nextWaiter = null;
        } while (!transferForSignal(first) &&
                 (first = firstWaiter) != null);
    }

    /**
     * Removes and transfers all nodes.
     * @param first (non-null) the first node on condition queue
     */
    private void doSignalAll(Node first) {
        lastWaiter = firstWaiter = null;
        do {
            Node next = first.nextWaiter;
            first.nextWaiter = null;
            transferForSignal(first);
            first = next;
        } while (first != null);
    }

    /**
     * Unlinks cancelled waiter nodes from condition queue.
     * Called only while holding lock. This is called when
     * cancellation occurred during condition wait, and upon
     * insertion of a new waiter when lastWaiter is seen to have
     * been cancelled. This method is needed to avoid garbage
     * retention in the absence of signals. So even though it may
     * require a full traversal, it comes into play only when
     * timeouts or cancellations occur in the absence of
     * signals. It traverses all nodes rather than stopping at a
     * particular target to unlink all pointers to garbage nodes
     * without requiring many re-traversals during cancellation
     * storms.
     */
    private void unlinkCancelledWaiters() {
        Node t = firstWaiter;
        Node trail = null;
        while (t != null) {
            Node next = t.nextWaiter;
            if (t.waitStatus != Node.CONDITION) {
                t.nextWaiter = null;
                if (trail == null)
                    firstWaiter = next;
                else
                    trail.nextWaiter = next;
                if (next == null)
                    lastWaiter = trail;
            }
            else
                trail = t;
            t = next;
        }
    }

    // public methods

    /**
     * Moves the longest-waiting thread, if one exists, from the
     * wait queue for this condition to the wait queue for the
     * owning lock.
     *
     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
     *         returns {@code false}
     */
    public final void signal() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }

    /**
     * Moves all threads from the wait queue for this condition to
     * the wait queue for the owning lock.
     *
     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
     *         returns {@code false}
     */
    public final void signalAll() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignalAll(first);
    }

    /**
     * Implements uninterruptible condition wait.
     * <ol>
     * <li> Save lock state returned by {@link #getState}.
     * <li> Invoke {@link #release} with saved state as argument,
     *      throwing IllegalMonitorStateException if it fails.
     * <li> Block until signalled.
     * <li> Reacquire by invoking specialized version of
     *      {@link #acquire} with saved state as argument.
     * </ol>
     */
    public final void awaitUninterruptibly() {
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if (Thread.interrupted())
                interrupted = true;
        }
        if (acquireQueued(node, savedState) || interrupted)
            selfInterrupt();
    }

    /*
     * For interruptible waits, we need to track whether to throw
     * InterruptedException, if interrupted while blocked on
     * condition, versus reinterrupt current thread, if
     * interrupted while blocked waiting to re-acquire.
     */

    /** Mode meaning to reinterrupt on exit from wait */
    private static final int REINTERRUPT =  1;
    /** Mode meaning to throw InterruptedException on exit from wait */
    private static final int THROW_IE    = -1;

    /**
     * Checks for interrupt, returning THROW_IE if interrupted
     * before signalled, REINTERRUPT if after signalled, or
     * 0 if not interrupted.
     */
    private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
    }

    /**
     * Throws InterruptedException, reinterrupts current thread, or
     * does nothing, depending on mode.
     */
    private void reportInterruptAfterWait(int interruptMode)
        throws InterruptedException {
        if (interruptMode == THROW_IE)
            throw new InterruptedException();
        else if (interruptMode == REINTERRUPT)
            selfInterrupt();
    }

    /**
		线程进入等待
     * </ol>
     */
    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }

    /**
		带有超时时间的等待 纳秒级别
     * </ol>
     */
    public final long awaitNanos(long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (nanosTimeout <= 0L) {
                transferAfterCancelledWait(node);
                break;
            }
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return deadline - System.nanoTime();
    }

    /**
		等待到某一固定时刻
     * </ol>
     */
    public final boolean awaitUntil(Date deadline)
            throws InterruptedException {
        long abstime = deadline.getTime();
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        boolean timedout = false;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (System.currentTimeMillis() > abstime) {
                timedout = transferAfterCancelledWait(node);
                break;
            }
            LockSupport.parkUntil(this, abstime);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return !timedout;
    }

    /**
		带超时时间的等待
     * </ol>
     */
    public final boolean await(long time, TimeUnit unit)
            throws InterruptedException {
        long nanosTimeout = unit.toNanos(time);
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        boolean timedout = false;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (nanosTimeout <= 0L) {
                timedout = transferAfterCancelledWait(node);
                break;
            }
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return !timedout;
    }

    //  support for instrumentation

    /**
     * Returns true if this condition was created by the given
     * synchronization object.
     *
     * @return {@code true} if owned
     */
    final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
        return sync == AbstractQueuedSynchronizer.this;
    }

    /**
		是否有等待的线程
     */
    protected final boolean hasWaiters() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION)
                return true;
        }
        return false;
    }

    /**
		获取等待队列的长度
     */
    protected final int getWaitQueueLength() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int n = 0;
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION)
                ++n;
        }
        return n;
    }

    /**
		获取等待中的线程队列
     */
    protected final Collection<Thread> getWaitingThreads() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION) {
                Thread t = w.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }
}
```

##### 加锁

```java
// 如果获取锁失败
if (!tryAcquire(arg)) {
 // 入队, 可以选择阻塞当前线程 park unpark
}
```

##### 解锁

```java
// 如果释放锁成功 

if (tryRelease(arg)) { 

 // 让阻塞线程恢复运行 

} 
```

子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）  采用了模板设计模式

tryAcquire  ：加锁

tryRelease  ：解锁

tryAcquireShared  ：加共享锁

tryReleaseShared  ：解共享锁

isHeldExclusively ：锁是否独有

#### 24reentrantLock

##### 1非公平锁路线

​	加锁  ：如果当前线程竞争锁成功  aqs.owner =node.thread  线程node就会变成head结点并且使node.thread = null ，  如果加锁没成功 就会进入等待队列 (lockSupport.park) ，  等待被唤醒 .                                                     如果是发生了可重入锁aqs.state++; 

​	解锁：如果是可重入锁解锁 aqs.state --，如果只有一层锁  就把head.next.thread 唤醒  (lockSupport.unpark),

并且aqs.owner = null

###### 	1.1加锁

```java
final void lock() {
    if (compareAndSetState(0, 1)) //改变锁占有状态
        //加锁成功
        setExclusiveOwnerThread(Thread.currentThread()); //设置owner线程
    else
        //加锁失败
        acquire(1);//再尝试一次加锁  如果还是失败 加入等待队列
}
```

```java
//再尝试一次加锁  如果还是失败 加入等待队列
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

加入等待队列

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        //循环的加锁 解锁 直到加锁成功 node变成了头结点
        for (;;) {
            final Node p = node.predecessor();
            //把当前节点 设成等待队列的头节点
            if (p == head && tryAcquire(arg)) {
                setHead(node);//加锁成功后 就变成头结点 清空node里的线程对象
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //加锁失败 调用LockSupport.park使线程等待  直到下次被唤醒
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

非公平锁可重入加锁

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {//如果是没加锁 就进行加锁
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //如果已经被加锁 但是线程是当前线程  state++
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires; //state++
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

###### 1.2 解锁

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {//尝试解锁  如果是重入锁发生 返回fasle 否则返回true
        Node h = head;
        if (h != null && h.waitStatus != 0)//判断头结点是否不为空 并且 头结点的waitStatus！=0
            unparkSuccessor(h); //解锁头结点的next节点  lockSupport.unpark
        return true;
    }
    return false;
}
```

```java
//尝试解锁  如果是重入锁发生 返回fasle 否则返回true
protected final boolean tryRelease(int releases) {
    int c = getState() - releases; //state-- 
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {//如果是没有重入发生 设置owner为空
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

```java
//解锁代码
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread); //解锁node.next.thread
}
```

##### 2公平锁路线

加锁

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        //判断等待队列有没有node在等待 如果没有 加锁成功 
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //判断是否锁重入
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

解锁与非公平锁一致

##### 3条件变量

wait:在condition中有一个waitlist 调用了await方法之后  会在队列尾部添加一个node并且把 state置为0；然后LockSupport.park();

singal: 会把waitList的第一个等待节点 放到blocklList 的尾部  然后唤醒节点的线程（LockSupport.unpark()），之后由于锁还没被释放 ，进行锁重入。

###### 3.1 await

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter(); //往等待队列尾部添加node
    int savedState = fullyRelease(node);//返回State 并且把state置为0 并且唤醒等待队列中的next节点
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {//如果不是在阻塞队列中
        LockSupport.park(this);//阻塞当前线程
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    //被唤醒后
    //如果存在于阻塞队列中  
    //锁重入，state还原
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```

​	

###### 3.2 singal

```java
private void doSignal(Node first) {
    do {
        //链表迭代
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &&  //把first节点从conditionlist 转移到blocklist的尾部
             (first = firstWaiter) != null);	//链表迭代 如果转移失败 转移frist.nextWaiter
}
```

```java
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    Node p = enq(node); //放入bolckList 的尾部
    int ws = p.waitStatus;
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread); //唤醒线程
    return true;
}
```

#### 26 reentrantReadWriteLock

读-读可以并发，读-写不能并发，写-写不能并发

持有读锁不支持升级成写锁

持有写锁支持降级成读锁

##### 缓存应用

缓存更新策略1：先清楚缓存 后更新数据库  

![1587488462032](img/1587488462032.png)

T1 清空缓存

T2 查询缓存发现为空 去数据库查询 x=1 并放入缓存

T1 更新数据库 x=2

T3 ,T4,T5 ..... 查询 发现缓存不为空 返回旧数据x=1 ！！！！！！！



缓存更新策略2：先更新数据库 再删除缓存

![1587488740652](img/1587488740652.png)

T1 更新数据库 x=2

T2 查询发现缓存不为空 返回x=1  ！！！！！！ 但是时间非常短

T1 清空缓存

T3 ,T4,T5 ..... 查询 发现缓存为空  去数据库查询 返回数据x=2

![1587488980542](img/1587488980542.png)



第三种情况 概率非常小

问题根源  更新数据库和清除缓存不是一个原子操作

我们通过加锁来使他变成一个原子操作



```java

class GenericCachedDao<T> {

    // HashMap 作为缓存非线程安全, 需要保护 

    HashMap<SqlPair, T> map = new HashMap<>();


    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    GenericDao genericDao = new GenericDao();

    public int update(String sql, Object... params) {

        SqlPair key = new SqlPair(sql, params);
        //加上读锁 保证一个原子性
        lock.writeLock().lock();
        try {
            int rows = genericDao.update(sql, params);
            map.clear();
            return rows;
        } finally {
            lock.writeLock().unlock();
        }
    }

    public T queryOne(Class<T> beanClass, String sql, Object... params) {
        SqlPair key = new SqlPair(sql, params);
        // 加读锁, 防止其它线程对缓存更改
        lock.readLock().lock();
        try {
            T value = map.get(key);
            if (value != null) {
                return value;
            }
        } finally {
            lock.readLock().unlock();
        }
        // 加写锁, 防止其它线程对缓存读取和更改
        lock.writeLock().lock();
        try {
            // get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据
            // 为防止重复查询数据库, 再次验证
            T value = map.get(key);
            if (value == null) {
                // 如果没有, 查询数据库
                value = genericDao.queryOne(beanClass, sql, params);
                map.put(key, value);
            }
            return value;
        } finally {
            lock.writeLock().unlock();
        }
    }
}
```

##### status

​	 int 前16bit代表读    int后16位代表写锁

##### 写锁

​		加锁

```java
public final void acquire(int arg) {
    //执行加锁 如果加锁失败 添加到阻塞队列  模式：独占
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

```java
protected final boolean tryAcquire(int acquires) {
    /*
     * Walkthrough:
     * 1. If read count nonzero or write count nonzero
     *    and owner is a different thread, fail.
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c); //获取写锁    c&((1<<16)-1)
    if (c != 0) { //已经被加锁
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
           	//其他线程占有锁  加锁失败
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            //超过重入上限
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        //如果上面两个 if 都不满足 进行锁重入
        setState(c + acquires);
        return true;
    }
    //如果不是锁重入  执行加锁
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
```

​		解锁

```
public final boolean release(int arg) {
    if (tryRelease(arg)) {//如果解锁成功
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);//唤醒后面的节点作为头结点
        return true;
    }
    return false;
}
```

##### 读锁

​		加锁

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0) //尝试加上共享锁
        //如果加锁失败  进入阻塞队列 添加的node模式为共享模式
        doAcquireShared(arg);
}
```

​		

```java
protected final int tryAcquireShared(int unused) {
    /*
     * Walkthrough:
     * 1. If write lock held by another thread, fail.
     * 2. Otherwise, this thread is eligible for
     *    lock wrt state, so ask if it should block
     *    because of queue policy. If not, try
     *    to grant by CASing state and updating count.
     *    Note that step does not check for reentrant
     *    acquires, which is postponed to full version
     *    to avoid having to check hold count in
     *    the more typical non-reentrant case.
     * 3. If step 2 fails either because thread
     *    apparently not eligible or CAS fails or count
     *    saturated, chain to version with full retry loop.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    //已经加上了写锁 或者别的线程占有了锁 返回-1
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c); //获取读锁   c>>>16 
    //读锁并发
    if (!readerShouldBlock() &&
        r < MAX_COUNT &&
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {//没有读锁
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {//同线程读锁重入
            firstReaderHoldCount++;
        } else {
            //多线程读锁并发
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++; //读锁计数+1
        }
        return 1;//加锁成功返回 1
    }
    //如果if不满足 不停的循环（唤醒/等待）直到加锁成功
    return fullTryAcquireShared(current);
}
```

```java
final int fullTryAcquireShared(Thread current) {
    /*
     * This code is in part redundant with that in
     * tryAcquireShared but is simpler overall by not
     * complicating tryAcquireShared with interactions between
     * retries and lazily reading hold counts.
     */
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1; //存在读锁并且写锁不是同一个线程 返回加锁失败
            // else we hold the exclusive lock; blocking here
            // would cause deadlock.
        } else if (readerShouldBlock()) {
            // Make sure we're not acquiring read lock reentrantly
            if (firstReader == current) {
                // assert firstReaderHoldCount > 0;
            } else {
                if (rh == null) {
                    rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current)) {
                        rh = readHolds.get();
                        if (rh.count == 0)
                            readHolds.remove();
                    }
                }
                if (rh.count == 0)
                    return -1;
            }
        }
        if (sharedCount(c) == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        //多线程并发加读锁
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (sharedCount(c) == 0) {//设置第一个读锁
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;//重入
            } else { //多线程设置读锁
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
            return 1; //加锁成功 返回1  
        }
        //如果加锁失败 进入下一次循环  直到多线程读锁加锁成功
    }
}
```

```java
javaprivate void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);//添加共享节点
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();//前继节点
            if (p == head) {
                int r = tryAcquireShared(arg);//加锁
                if (r >= 0) {
                    //加锁成功 把下一个节点设置成head 并且唤醒下一个节点 也进行加锁
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //如果加锁失败 进入阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```java
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don't know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared(); //如果下一个节点是shard模式  继续唤醒下一个节点 形成递归 直到遇到读锁或者为null时 才停止   把所有的shard的node全部解锁 
    }
}
```

解锁

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

```java
protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
    if (firstReader == current) {
        // assert firstReaderHoldCount > 0;
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--; 
    } else {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count <= 1) {
            readHolds.remove();
            if (count <= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT; //减少读锁状态
        if (compareAndSetState(c, nextc))
            // Releasing the read lock has no effect on readers,
            // but it may allow waiting writers to proceed if
            // both read and write locks are now free.
            return nextc == 0; //如果读锁全部释放完 返回ture  否则 返回false
    }
}
```

```java
/**
 * Release action for shared mode -- signals successor and ensures
 * propagation. (Note: For exclusive mode, release just amounts
 * to calling unparkSuccessor of head if it needs signal.)
 */
private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

读锁加锁流程 支持并发 如果加锁成功 就不放入blocklist  如果遇到写锁 则阻塞 添加nodeshard模式到blocklist



读锁解锁流程  头节点解锁 把下一节点变成头结点 如果下一节点还是shard模式 就唤醒  并设置下下节点为头结点 如果下下节点还是shard模式 ...... 直到遇到写锁 

#### 27StampedLock

默认无锁 支持锁的验证  

优点：可以支持读读并发 性能最极限  因为他读读并发的时候 不会修改states  支持锁升级 可以从无锁变成读锁  也可以变成写锁

缺点：不支持条件变量  不支持锁重入

#### 28Semaphore信号量

可以设定一个大小  来控制运行线程的多少

```java
public static void main(String[] args) {
    Semaphore semaphore = new Semaphore(3);
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            try {
                semaphore.acquire();
                log.debug("开始");
                Sleeper.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log.debug("结束");
                semaphore.release();
            }
        }).start();
    }
}
//23:13:23.182 demo.semaPhore.SemaphoreTest [Thread-1] - 开始
//23:13:23.182 demo.semaPhore.SemaphoreTest [Thread-2] - 开始
//23:13:23.183 demo.semaPhore.SemaphoreTest [Thread-0] - 开始
//23:13:25.188 demo.semaPhore.SemaphoreTest [Thread-2] - 结束
//23:13:25.188 demo.semaPhore.SemaphoreTest [Thread-1] - 结束
//23:13:25.188 demo.semaPhore.SemaphoreTest [Thread-0] - 结束
//23:13:25.188 demo.semaPhore.SemaphoreTest [Thread-3] - 开始
//23:13:25.188 demo.semaPhore.SemaphoreTest [Thread-4] - 开始
//23:13:25.188 demo.semaPhore.SemaphoreTest [Thread-6] - 开始
//23:13:27.189 demo.semaPhore.SemaphoreTest [Thread-4] - 结束
//23:13:27.189 demo.semaPhore.SemaphoreTest [Thread-3] - 结束
//23:13:27.189 demo.semaPhore.SemaphoreTest [Thread-6] - 结束
//23:13:27.189 demo.semaPhore.SemaphoreTest [Thread-7] - 开始
//23:13:27.189 demo.semaPhore.SemaphoreTest [Thread-5] - 开始
//23:13:27.189 demo.semaPhore.SemaphoreTest [Thread-8] - 开始
//23:13:29.189 demo.semaPhore.SemaphoreTest [Thread-7] - 结束
//23:13:29.189 demo.semaPhore.SemaphoreTest [Thread-5] - 结束
//23:13:29.189 demo.semaPhore.SemaphoreTest [Thread-8] - 结束
//23:13:29.189 demo.semaPhore.SemaphoreTest [Thread-9] - 开始
//23:13:31.190 demo.semaPhore.SemaphoreTest [Thread-9] - 结束
```

#### 29 CountDownLatch

一个可以支持计数的锁  开始设置一个计数  等待的线程直到计数减为0之后 才开始执行  

共享锁模式 head.next 节点解锁后  会唤醒所有阻塞的节点

```java
@Slf4j
public class TestCountDownLatch {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3); //设置计数3
        log.debug("开始等待");
        new Thread(() ->{
            Sleeper.sleep(1);
            latch.countDown();//计数-1
            log.debug("stop");
        }).start();
        new Thread(() ->{
            Sleeper.sleep(1);
            latch.countDown();//计数-1
            log.debug("stop");
        }).start();
        new Thread(() ->{
            Sleeper.sleep(1);
            latch.countDown();//计数-1
            log.debug("stop");
        }).start();
        latch.await();
        log.debug("等待结束");
    }
}
```

#### 30 ConCurrentHashMap

##### hashmap的并发问题

​		**1. JDK 7 HashMap** **并发死链**

​				

```java
        void transfer(Entry[] newTable, boolean rehash) {
            int newCapacity = newTable.length;
            for (Entry<K,V> e : table) {
                while(null != e) {
                    Entry<K,V> next = e.next;
                    // 1 处
                    if (rehash) {
                        e.hash = null == e.key ? 0 : hash(e.key);
                    }
                    int i = indexFor(e.hash, newCapacity);
                    // 2 处
                    // 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                }
            }
        }
```

```java
链表原长度为16 扩容后为32
原始链表，格式：[下标] (key,next) [1] (1,33)->(33,17)->(17,null)
线程 a 执行到 1 处 ，此时局部变量 e 为 (1,33)，而局部变量 next 为 (33,17) 线程 a 挂起
线程 b 开始执行
第一次循环
[1] (1,null)
第二次循环
[1] (33,1)->(1,null)
第三次循环
[1] (33,1)->(1,null) 
[17] (17,null)
切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (1,null)，而 next 的内
容被改为 (33,1) 并链向 (1,null)
第一次循环
[1] (1,null)
第二次循环，注意这时 e 是 (33,1) 并链向 (1,null) 所以 next 又是 (1,null) [1] (33,1)->(1,null)
第三次循环，e 是 (1,null)，而 next 是 null，但 e 被放入链表头，这样 e.next 变成了 33 （2 处）
[1] (1,35)->(35,1)->(1,35)
已经是死链了
```

总结：由于头插法会改变原来链表的顺序 所以可能出现多个线程同时扩容的时候  a线程还是按照从上到下遍历  但内存中的链表顺序已经反了  从而出现环状链表

jdk 1.8 采用了尾插法  从而避免了内存中链表顺序颠倒的问题  还是保持原来的顺序关系  

```java
//put方法 也会存在线程安全问题
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
         //如果此时两个线程都进入了这里  势必有一个元素会被覆盖掉  造成丢元素   
        tab[i] = newNode(hash, key, value, null);
```

##### SIZECTL

​		sizeCtl是用于多线程之间同步的一个互斥变量。当sizeCtl < 0时，表示已经有线程正在初始化哈希表或哈希表正在扩容，此时，不能再进行操作。



##### get 方法

 和普通的hashmap 差不多 先定位数组下标 然后从头到尾查找元素 找到即返回  没找到返回null

##### put方法

```java
/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    //不允许put空值
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode()); //重新计算哈希
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();//初始化table 内部用cas保证单例初始化
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            //如果table[i]没有值 就用cas赋值
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        // 如果是ForwardingNode
        else if ((fh = f.hash) == MOVED) //如果是forwardingNode
            // 帮忙扩容
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            //加锁的put 加锁的对象为对应链表的头结点 锁粒度较细 和普通hashmap的put差不多
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh >= 0) {
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value; //找到了key对应的node 覆盖值
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) { //没找到 添加节点
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
                // 释放链表头节点的锁
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount); //添加链表计数  
    return null;
}
```

##### initTable

```java
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) < 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            //使用cas把SIZECTL 改成-1 如果修改成功 进入初始化环境 如果失败进入下轮循环直到循环条件不符合
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2); //sc变成扩容阈值
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

##### transfer

主要流程：

1把数组容量*2

2确定当前线程的扩容区间

3进行扩容逻辑 把原来的链表拆分成2条链表  hash&length==0?this:another    1条保留 1条搬迁

```java
/**
 * Moves and/or copies the nodes in each bin to new table. See
 * above for explanation.
 * 
 * transferIndex 表示转移时的下标，初始为扩容前的 length。
 * 
 * 我们假设长度是 32
 */
private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    int n = tab.length, stride;
    // 将 length / 8 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16。
    // 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶
    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range 细分范围 stridea：TODO
    // 新的 table 尚未初始化
    if (nextTab == null) {            // initiating
        try {
            // 扩容  2 倍
            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
            // 更新
            nextTab = nt;
        } catch (Throwable ex) {      // try to cope with OOME
            // 扩容失败， sizeCtl 使用 int 最大值。
            sizeCtl = Integer.MAX_VALUE;
            return;// 结束
        }
        // 更新成员变量
        nextTable = nextTab;
        // 更新转移下标，就是 老的 tab 的 length
        transferIndex = n;
    }
    // 新 tab 的 length
    int nextn = nextTab.length;
    // 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。
    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
    // 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进
    boolean advance = true;
    // 完成状态，如果是 true，就结束此方法。
    boolean finishing = false; // to ensure sweep before committing nextTab
    // 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标
    for (int i = 0, bound = 0;;) {
        Node<K,V> f; int fh;
        // 如果当前线程可以向后推进；这个循环就是控制 i 递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间
        while (advance) {
            int nextIndex, nextBound;
            // 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）
            // 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。
            // 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。
            if (--i >= bound || finishing)
                advance = false;// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进
            // 这里的目的是：1. 当一个线程进入时，会选取最新的转移下标。2. 当一个线程处理完自己的区间时，如果还有剩余区间的没有别的线程处理。再次获取区间。
            else if ((nextIndex = transferIndex) <= 0) {
                // 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了
                // 这个 -1 会在下面的 if 块里判断，从而进入完成状态判断
                i = -1;
                advance = false;// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进
            }// CAS 修改 transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex > stride ?
                                   nextIndex - stride : 0))) {
                bound = nextBound;// 这个值就是当前线程可以处理的最小当前区间最小下标
                i = nextIndex - 1; // 初次对i 赋值，这个就是当前线程可以处理的当前区间的最大下标
                advance = false; // 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进，这样对导致漏掉某个桶。下面的 if (tabAt(tab, i) == f) 判断会出现这样的情况。
            }
        }// 如果 i 小于0 （不在 tab 下标内，按照上面的判断，领取最后一段区间的线程扩容结束）
        //  如果 i >= tab.length(不知道为什么这么判断)
        //  如果 i + tab.length >= nextTable.length  （不知道为什么这么判断）
        if (i < 0 || i >= n || i + n >= nextn) {
            int sc;
            if (finishing) { // 如果完成了扩容
                nextTable = null;// 删除成员变量
                table = nextTab;// 更新 table
                sizeCtl = (n << 1) - (n >>> 1); // 更新阈值
                return;// 结束方法。
            }// 如果没完成
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {// 尝试将 sc -1. 表示这个线程结束帮助扩容了，将 sc 的低 16 位减一。
                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)// 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。
                    return;// 不相等，说明没结束，当前线程结束方法。
                finishing = advance = true;// 如果相等，扩容结束了，更新 finising 变量
                i = n; // 再次循环检查一下整张表
            }
        }
        else if ((f = tabAt(tab, i)) == null) // 获取老 tab i 下标位置的变量，如果是 null，就使用 fwd 占位。
            advance = casTabAt(tab, i, null, fwd);// 如果成功写入 fwd 占位，再次推进一个下标
        else if ((fh = f.hash) == MOVED)// 如果不是 null 且 hash 值是 MOVED。
            advance = true; // already processed // 说明别的线程已经处理过了，再次推进一个下标
        else {// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点上锁。为什么上锁，防止 putVal 的时候向链表插入数据
            synchronized (f) { //扩容时，只在这个环节加锁
                // 判断 i 下标处的桶节点是否和 f 相同
                if (tabAt(tab, i) == f) {
                    Node<K,V> ln, hn;// low, height 高位桶，低位桶
                    // 如果 f 的 hash 值大于 0 。TreeBin 的 hash 是 -2
                    if (fh >= 0) {
                        // 对老长度进行与运算（第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0）
                        // 由于 Map 的长度都是 2 的次方（000001000 这类的数字），那么取于 length 只有 2 种结果，一种是 0，一种是1
                        //  如果是结果是0 ，Doug Lea 将其放在低位，反之放在高位，目的是将链表重新 hash，放到对应的位置上，让新的取于算法能够击中他。
                        int runBit = fh & n;
                        Node<K,V> lastRun = f; // 尾节点，且和头节点的 hash 值取于不相等
                        // 遍历这个桶
                        for (Node<K,V> p = f.next; p != null; p = p.next) {
                            // 取于桶中每个节点的 hash 值
                            int b = p.hash & n;
                            // 如果节点的 hash 值和首节点的 hash 值取于结果不同
                            if (b != runBit) {
                                runBit = b; // 更新 runBit，用于下面判断 lastRun 该赋值给 ln 还是 hn。
                                lastRun = p; // 这个 lastRun 保证后面的节点与自己的取于值相同，避免后面没有必要的循环
                            }
                        }
                        if (runBit == 0) {// 如果最后更新的 runBit 是 0 ，设置低位节点
                            ln = lastRun;
                            hn = null;
                        }
                        else {
                            hn = lastRun; // 如果最后更新的 runBit 是 1， 设置高位节点
                            ln = null;
                        }// 再次循环，生成两个链表，lastRun 作为停止条件，这样就是避免无谓的循环（lastRun 后面都是相同的取于结果）
                        for (Node<K,V> p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            // 如果与运算结果是 0，那么就还在低位
                            if ((ph & n) == 0) // 如果是0 ，那么创建低位节点
                                ln = new Node<K,V>(ph, pk, pv, ln);
                            else // 1 则创建高位
                                hn = new Node<K,V>(ph, pk, pv, hn);
                        }
                        // 其实这里类似 hashMap 
                        // 设置低位链表放在新链表的 i
                        setTabAt(nextTab, i, ln);
                        // 设置高位链表，在原有长度上加 n
                        setTabAt(nextTab, i + n, hn);
                        // 将旧的链表设置成占位符
                        setTabAt(tab, i, fwd);
                        // 继续向后推进
                        advance = true;
                    }// 如果是红黑树
                    else if (f instanceof TreeBin) {
                        TreeBin<K,V> t = (TreeBin<K,V>)f;
                        TreeNode<K,V> lo = null, loTail = null;
                        TreeNode<K,V> hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        // 遍历
                        for (Node<K,V> e = t.first; e != null; e = e.next) {
                            int h = e.hash;
                            TreeNode<K,V> p = new TreeNode<K,V>
                                (h, e.key, e.val, null, null);
                            // 和链表相同的判断，与运算 == 0 的放在低位
                            if ((h & n) == 0) {
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            } // 不是 0 的放在高位
                            else {
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            }
                        }
                        // 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树
                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                            (hc != 0) ? new TreeBin<K,V>(lo) : t;
                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                            (lc != 0) ? new TreeBin<K,V>(hi) : t;
                        // 低位树
                        setTabAt(nextTab, i, ln);
                        // 高位数
                        setTabAt(nextTab, i + n, hn);
                        // 旧的设置成占位符
                        setTabAt(tab, i, fwd);
                        // 继续向后推进
                        advance = true;
                    }
                }
            }
        }
    }
}
```

##### helpTransfer

```java
//帮助扩容
final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
    Node<K,V>[] nextTab; int sc;
    //如果当前节点是ForwardingNode 说明当前节点扩容完成 需要帮助其他节点扩容 
    if (tab != null && (f instanceof ForwardingNode) &&
        (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable && table == tab &&
               (sc = sizeCtl) < 0) {
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex <= 0)
                break;
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                //如果cas成功 帮助扩容
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
```

#### 31 ThreadLocal

是一个对象 可以往每个线程的ThreadLocalMap 中添加节点

用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。

```java
// ThreadLocalMap
类似于hashmap 但是没有使用链表法 如果hash冲突了 就向后节点查询 看是否有空节点可以set
        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
```

简单解析一下，get方法的流程是这样的：

> 1、首先获取当前线程；
> 2、根据当前线程获取一个Map；
> 3、如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e，否则转到5；
> 4、如果e不为null，则返回e.value，否则转到5；
> 5、Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map。

set方法

```java
private void set(ThreadLocal<?> key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    //通过与运算计算下标
    int i = key.threadLocalHashCode & (len-1);
    //进行从i下标向后遍历查找  e = tab[i = nextIndex(i, len)]可以理解为i++;
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();
		//如果找到对应的节点 覆盖值
        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }
	//走到这里说明找到了null节点  那就新建节点
    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```



threadlocalmap 在get 或set的时候 如果发现key=null的情况 会进行删除对应节点 避免threadlocal被gc从而导致的 内存泄漏

但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。