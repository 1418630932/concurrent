# 多线程学习笔记

#### 1 jvm中线程隔离的区域

​        程序计数器 （记录当前线程执行到哪一行代码）

​		本地方法栈

​		虚拟机栈： 栈帧包含（局部变量表 操作数栈  方法出口 锁记录等）

​		每一个方法执行相当于一个栈帧入栈到出栈的过程

#### 2 cpu的线程上下文切换

​		为了保证每个线程都能运行到 cpu会给每个线程分配时间片（如15ms） 

当cpu时间片的时间耗尽 就需要保存当前线程的信息 然后去执行另外一个线程的时间片

这个过程就是cpu的线程上下文切换

执行上下文切换的时机：

​				线程的 cpu 时间片用完 

​				垃圾回收 

​				有更高优先级的线程需要运行 

​				线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 

当 Context Switch（线程上下文切换） 发生时，需要由操作系统保存**当前线程的状态**，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 

当前线程的状态包括：程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 

Context Switch 频繁发生会影响性能

#### 3线程的基本操作

start():启动一个新线 程，在新的线程 运行 run 方法 中的代码 

join():等待线程运行结束

sleep():让线程休眠n毫秒 休眠时让出cpu时间片

interrupt():打断线程 并且把打断标记设置为true 

​					如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除打					标记 （打断标记=false）；

​					如果打断的正在运行的线程，则会设置 打断标记(打断标记=true) ；

​					park 的线程被打断，也会设置打断标记 

isInterrupted():返回打断标记

interrupted():返回线程是否被打断线程  并会清楚打断标记

currentThread():返回当前线程

#### 4设计模式：两阶段终止

​	如何优雅的终止线程

```java
package demo.n2.util;

/**
 * @author zhuliyang
 * @date 2020-03-29
 * @time 23:24
 **/
public class TwoPhaseTermination {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination t = new TwoPhaseTermination();
        t.start();
        Thread.sleep(5000);
        t.stop();
    }
    Thread monitor;
    //启动监控线程
    public void start(){
        monitor = new Thread(()->{
            while (true){
                if (Thread.currentThread().isInterrupted()){
                    System.out.println("料理后事");
                    break;
                }
                System.out.println("监控线程");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();//设置打断标记
                }
            }
        });
        monitor.start();
    }
    //结束监控线程
    public void stop(){
        monitor.interrupt();
    }
}
```

#### 5线程的6种状态

NEW:   线程创建出来但是没有运行

RUNNABLE： 线程正在运行中

BLOCKED	：线程由于锁的关系 进入阻塞状态

WAITING	：线程进入无限期等待

TIMED_WATING ：线程进入有限时间的等待

TERMINATED	：线程结束运行

#### 6synchronized

